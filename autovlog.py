# autoblog.py

from moviepy.editor import *
import os
import re
from google.oauth2 import service_account
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from googleapiclient.http import MediaFileUpload

def upload_video_to_youtube(video_file, title, description, category_id, tags, credentials_json):
    try:
        # Authenticate using the service account JSON file
        credentials = service_account.Credentials.from_service_account_file(credentials_json)
        youtube = build('youtube', 'v3', credentials=credentials)

        body = {
            'snippet': {
                'title': title,
                'description': description,
                'tags': tags,
                'categoryId': category_id
            },
            'status': {
                'privacyStatus': 'public'  # Set the privacy status of the uploaded video
            }
        }

        # Upload the video
        media = MediaFileUpload(video_file, chunksize=-1, resumable=True, mimetype='video/mp4')
        request = youtube.videos().insert(part=','.join(body.keys()), body=body, media_body=media)
        response = request.execute()

        # Return the video ID
        return response['id']
    except HttpError as e:
        print(f'An error occurred: {e}')
        return None


def generate_video(background_image, tts_mp3, output_video, text_content):
    # Load the background image and the TTS MP3 file
    image_clip = ImageClip(background_image)
    audio_clip = AudioFileClip(tts_mp3)

    # Set the duration of the image clip to match the duration of the audio clip
    image_clip = image_clip.set_duration(audio_clip.duration)

    # Create a TextClip with your desired text content, font, size, and color
    text_clip = TextClip(text_content, fontsize=50, color='white', font='Arial-Bold')
    text_clip = text_clip.set_position('center').set_duration(audio_clip.duration)

    # Overlay the text on the background image
    final_clip = CompositeVideoClip([image_clip, text_clip])

    # Set the audio of the final clip to the TTS MP3 file
    final_clip = final_clip.set_audio(audio_clip)

    # Write the final video to a file
    final_clip.write_videofile(output_video, fps=24, codec='libx264')


def process_blog_posts(posts_dir, audio_dir, default_video_src, background_image):
    for file in os.listdir(posts_dir):
        if file.endswith(".md"):
            file_path = os.path.join(posts_dir, file)

            with open(file_path, 'r', encoding='utf-8') as post_file:
                content = post_file.read()

            # Check if the post contains the default video src
            if default_video_src in content:
                # Extract date and title from the filename
                date, title = os.path.splitext(file)[0].split('-', 1)

                # Create the path to the TTS MP3 file
                tts_mp3 = os.path.join(audio_dir, f'{date}-{title}.mp3')

                # Check if the TTS MP3 file exists
                if os.path.isfile(tts_mp3):
                    # Generate the video using the generate_video function
                    output_video = f'output_videos/{date}-{title}.mp4'
                    generate_video(background_image, tts_mp3, output_video, title.replace('-', ' '))
                    print(f"Video generated: {output_video}")

                    # Upload the video to YouTube and get the video ID
                    video_id = upload_video_to_youtube(
                        output_video,
                        title.replace('-', ' '),
                        f"Autogenerated video for blog post: {title.replace('-', ' ')}",
                        '22',  # Category ID (22 is for "People & Blogs", change as needed)
                        ['autovlog', 'JPyPA'],  # Tags (change as needed)
                        'C:/Users/darde/code/credentials.json'  # Absolute path to your credentials file
                    )

                    if video_id:
                        print(f'Uploaded video to YouTube, Video ID: {video_id}')
                        # Replace the default video source with the new video link in the post content
                        updated_content = content.replace(
                            default_video_src,
                            f'https://www.youtube.com/watch?v={video_id}'
                        )

                        # Write the updated content back to the blog post file
                        with open(file_path, 'w', encoding='utf-8') as post_file:
                            post_file.write(updated_content)
                        print(f"Updated blog post with new video link: {file}")

if __name__ == "__main__":
    posts_dir = '_posts'
    audio_dir = 'assets/audio'
    default_video_src = '/output_video/default.mp4'  # Replace with your default video src
    background_image = 'background.jpg'  # Replace with the path to your background image

    # Create a directory for output videos if it doesn't exist
    if not os.path.exists('output_videos'):
        os.makedirs('output_videos')

    process_blog_posts(posts_dir, audio_dir, default_video_src, background_image)
